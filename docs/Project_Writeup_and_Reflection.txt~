Project Overview:
We made a multi-game arcade, with (currently) three fully-functional games. The first game we offer is Dot Shooter, an Asteroids-like game where the debris around you becomes your ammunition, used in fending off the endless, single-file horde of enemies. The second game is Conway's Game of Life, a "zero-player game" in which the user sets up an initial state and can see how life unfolds. The third game is Super Meat Boy, a simple platformer implementation.

Results:
We have three functional games and a simple GUI that lets the user choose which game they want to play.

Dot Shooter has simple gameplay revolving around avoiding incoming red dots while firing back at them with ammo that is picked up in the environment. As the game progresses, more and more enemies arrive until the player is eventually overwhelmed, at which point they are shown how many enemies they defeated before dieing. The controls are simple; 4 buttons (WASD) control movement in a 2D plane, and a 5th button (M1) controls the picking up and firing of ammo. When the button is held, the player sucks up nearby balls, and when it is released a stream of balls is shot out in the direction of the mouse, with the number of balls in the stream corresponding to how many were picked up. The main focus of this game was visual effects, with the number of balls currently held being displayed faintly in the background such that it is easily readable but not intrusive to the game. The projectiles that the player shoots glow bright yellow and cool off to the normal dark green as they slow down, and enemies release an explosion of balls on death, introducing more ammo to the playing field.

The Game of Life is an interactive simulation, where the user can modify the game state prior to and during the execution of the program. A collection of life forms are represented by squares in a grid, and the number of neighboring "alive" cells is used to calculate whether other grid points will live or die in the next generation. Running off this basic set of laws, designs such as gliders emerge from seemingly random collections of blocks. This game is more focused on emergent gameplay, where a simple set of rules leads to the emergence of classes of life forms and archetypes. Input is generally done with the mouse, where left-click (M1) toggles the state of the currently-hovered-over cell between dead and alive. The spacebar is used to pause or play the game, so that the player can edit the grid without creating premature interactions. 1-9 can be used to save up to 9 different game states, and F1-F9 can be used to load them.

The Super Meat Boy game is a simplified take on the popular platformer model, where a user navigates their avatar through a course, avoiding obstacles with the goal of reaching the end of the stage. The controls are simple; two keys, A and D, control movement to the left and right, and a third (W) jumps so that the player can traverse gaps and climb to higher platforms. In addition to the platform layout, the other main obstacle that players need to watch out for is the presence of enemies. Some are mobile, some are stationary, but all will kill the player with a single touch. This game is mainly focused on the mastering of technical skills and timing, as manipulating the movement of the avatar is key to completing every stage.

Implementation:
We chose to create two importable files, utils.py and base.py, to hold all of the common objects that we used in our games.
DAN: utils.py has my additional classes used in the Dot Shooter game. Every dot in the background is its own object, keeping track of its own position and velocity. I made the decision to store both position and velocity as vectors instead of using a Point class for position, because I could see no benefit to using a Point when I could just reuse the Vector class again for even more functionality. I created this Vector class so that I could easily manipulate the positions and velocities of objects. Since a vector is just a x and y coordinate, it was relatively easy to implement, and include functions to calculate things like the unit vector and magnitude. I was also able to overload common operators such as '+' to allow for concise Vector operations. When doing this I gave the user two options, they could modify the existing Vector by using the add() method, or they could generate a completely new vector by using the '+' operator. This proved to be useful in optimizing my code. The main game process iterates through all the balls present, moves them properly, and then queues them up to be drawn. The same is done for all the enemies and the player. When the enemies are moved, a check is done to see if any balls are near enough and fast enough to kill them, and if they are close enough to the player to kill him.
JOEY: base.py contains my implementation of a few different classes. The first is the basic Box class, which is little more than a custom version of PyGame's Rect. However, I used these Boxes for the level pieces in Super Meat Boy, and it is from Box that I subclassed Entity, which is a little more useful. An Entity is a Box with the possibility of motion, adding both fields for velocity and methods to move the Entity. The enemies in SMB are Entities, and the player object (MeatBoy) subclasses Entity to add state variables such as whether or not the player is touching the ground, or their current number of deaths. Next, we can see the implementation of a Level class; it is, at its core, a collection of lists containing level pieces, enemies, and goal pieces (implemented as Boxes, Entities, and Boxes respectively). levels.py contains the code that actually creates the levels used in SMB. The final class defined in base.py is the Camera class, which contains all of the methods for SMB's interaction with the computer's video input device (using OpenCV). When I made the Game of Life, I had no need for these classes; the data is stored in a 2D matrix (a list of lists) of boolean values to represent whether each cell is alive or dead, and all of the interaction is done through PyGame's events.
Please see UML.pdf for our unified model.

Reflection:
We feel that our project was appropriately scoped. We initially planned for some unknown number of games for our mini-arcade, but we quickly settled on three; the remnants of two more unfinished games can be found in the /code/ folder. As a group of two, our process was rather like that of two individuals, rather than a team. We each worked on our own game(s), and occasionally consulted each other for help. However, we feel that this was a very efficient method of working, and it was what we had planned from the beginning. There were no issues that arose, and we had a good time working with each other.
